# 系统架构优化方案：模块通信与解耦策略

## 当前架构分析
从整体系统.md文件可以看出，目前游戏包含9个核心模块和15个扩展模块，模块之间存在复杂的依赖关系：
- 角色属性系统和吞噬核心系统与多个模块直接关联
- 战斗系统依赖地图、妖兽、事件等多个系统
- 物品系统与角色、炼丹、装备、经济等系统紧密耦合

这种直接依赖的方式在模块数量较少时可行，但随着系统扩展，可能会导致以下问题：
1. 模块间耦合度高，修改一个模块可能影响多个其他模块
2. 通信逻辑分散，难以维护和追踪
3. 新模块接入成本高，需要修改多个现有模块

## 推荐架构方案：事件总线架构
### 核心思想
使用一个中央事件总线作为模块间通信的中介，模块通过发布/订阅事件进行交互，而不直接引用其他模块。事件总线作为消息传递的中央枢纽，实现模块间的解耦通信。

### 优点
- **低耦合度**：模块只需关心自己订阅的事件，不需要知道其他模块的存在
- **集中管理**：所有通信逻辑通过事件总线集中管理，便于追踪和调试
- **简单接入**：新模块只需订阅相关事件或发布新事件，无需修改现有模块
- **灵活通信**：支持一对多、多对多的通信模式，一个事件可以被多个模块响应
- **动态订阅**：支持运行时动态订阅和取消订阅事件，适应不同游戏状态

### 实现详细设计

#### 1. 事件总线核心类
```csharp
/// <summary>
/// 事件总线核心类，负责管理事件的发布和订阅
/// </summary>
public class EventBus
{
    // 存储事件名称和对应的回调函数列表
    private static readonly Dictionary<string, List<Action<object[]>>> _eventListeners = new();

    /// <summary>
    /// 订阅事件
    /// </summary>
    /// <param name="eventName">事件名称</param>
    /// <param name="callback">回调函数</param>
    public static void Subscribe(string eventName, Action<object[]> callback)
    {
        if (!_eventListeners.ContainsKey(eventName))
            _eventListeners[eventName] = new List<Action<object[]>>();
        _eventListeners[eventName].Add(callback);
    }

    /// <summary>
    /// 发布事件
    /// </summary>
    /// <param name="eventName">事件名称</param>
    /// <param name="args">事件参数</param>
    public static void Publish(string eventName, params object[] args)
    {
        if (_eventListeners.TryGetValue(eventName, out var listeners))
        {
            // 遍历所有订阅该事件的回调函数
            foreach (var callback in listeners)
            {
                try
                {
                    callback(args);
                }
                catch (Exception e)
                {
                    // 记录异常，避免一个模块的错误影响其他模块
                    GD.PrintErr($"Error in event handler for {eventName}: {e.Message}");
                }
            }
        }
    }

    /// <summary>
    /// 取消订阅事件
    /// </summary>
    /// <param name="eventName">事件名称</param>
    /// <param name="callback">要取消的回调函数</param>
    public static void Unsubscribe(string eventName, Action<object[]> callback)
    {
        if (_eventListeners.TryGetValue(eventName, out var listeners))
        {
            listeners.Remove(callback);
            if (listeners.Count == 0)
                _eventListeners.Remove(eventName);
        }
    }

    /// <summary>
    /// 清除所有事件订阅（主要用于测试）
    /// </summary>
    public static void Clear()
    {
        _eventListeners.Clear();
    }
}
```

#### 2. 事件定义与参数类
```csharp
/// <summary>
/// 事件名称常量类，集中管理所有事件名称
/// </summary>
public static class EventNames
{
    // 战斗相关事件
    public const string OnEnemyKilled = "OnEnemyKilled";
    public const string OnPlayerDamaged = "OnPlayerDamaged";
    public const string OnBattleStarted = "OnBattleStarted";
    public const string OnBattleEnded = "OnBattleEnded";

    // 角色相关事件
    public const string OnPlayerLevelUp = "OnPlayerLevelUp";
    public const string OnPlayerStatusChanged = "OnPlayerStatusChanged";
    public const string OnPlayerEquipmentChanged = "OnPlayerEquipmentChanged";

    // 物品相关事件
    public const string OnItemAdded = "OnItemAdded";
    public const string OnItemRemoved = "OnItemRemoved";
    public const string OnItemUsed = "OnItemUsed";

    // 吞噬系统相关事件
    public const string OnDevourCompleted = "OnDevourCompleted";
    public const string OnAbilityChanged = "OnAbilityChanged";
}

/// <summary>
/// 敌人被击杀事件参数
/// </summary>
public class EnemyKilledEventArgs
{
    public Enemy KilledEnemy { get; set; }
    public int ExperienceGained { get; set; }
    public Player Killer { get; set; }
}

/// <summary>
/// 玩家升级事件参数
/// </summary>
public class PlayerLevelUpEventArgs
{
    public Player Player { get; set; }
    public int OldLevel { get; set; }
    public int NewLevel { get; set; }
}
```

#### 3. 使用示例
```csharp
/// <summary>
/// 玩家模块
/// </summary>
public class PlayerModule
{
    private Player _player;

    public void Initialize(Player player)
    {
        _player = player;
        // 订阅敌人被击杀事件
        EventBus.Subscribe(EventNames.OnEnemyKilled, OnEnemyKilled);
        // 订阅玩家升级事件
        EventBus.Subscribe(EventNames.OnPlayerLevelUp, OnPlayerLevelUp);
    }

    private void OnEnemyKilled(object[] args)
    {
        if (args.Length > 0 && args[0] is EnemyKilledEventArgs eventArgs)
        {
            // 检查是否是当前玩家击杀的敌人
            if (eventArgs.Killer == _player)
            {
                // 获得经验值
                _player.GainExperience(eventArgs.ExperienceGained);
                GD.Print($"Player gained {eventArgs.ExperienceGained} experience points.");

                // 检查是否升级
                if (_player.CheckLevelUp())
                {
                    int oldLevel = _player.Level;
                    _player.LevelUp();
                    // 发布玩家升级事件
                    EventBus.Publish(EventNames.OnPlayerLevelUp, new PlayerLevelUpEventArgs
                    {
                        Player = _player,
                        OldLevel = oldLevel,
                        NewLevel = _player.Level
                    });
                }
            }
        }
    }

    private void OnPlayerLevelUp(object[] args)
    {
        if (args.Length > 0 && args[0] is PlayerLevelUpEventArgs eventArgs)
        {
            if (eventArgs.Player == _player)
            {
                GD.Print($"Player leveled up from {eventArgs.OldLevel} to {eventArgs.NewLevel}!");
                // 显示升级提示UI
                EventBus.Publish(EventNames.OnShowNotification, $"Level Up! Now Level {eventArgs.NewLevel}");
            }
        }
    }
}

/// <summary>
/// 战斗模块
/// </summary>
public class CombatModule
{
    public void ProcessBattle(Player player, Enemy enemy)
    {
        // 战斗逻辑...

        // 敌人被击杀
        if (enemy.Health <= 0)
        {
            // 发布敌人被击杀事件
            EventBus.Publish(EventNames.OnEnemyKilled, new EnemyKilledEventArgs
            {
                KilledEnemy = enemy,
                ExperienceGained = enemy.Experience,
                Killer = player
            });
        }
    }
}

/// <summary>
/// UI模块
/// </summary>
public class UIModule
{
    public void Initialize()
    {
        // 订阅显示通知事件
        EventBus.Subscribe(EventNames.OnShowNotification, OnShowNotification);
    }

    private void OnShowNotification(object[] args)
    {
        if (args.Length > 0 && args[0] is string message)
        {
            // 显示通知UI
            ShowNotificationPanel(message);
        }
    }

    private void ShowNotificationPanel(string message)
    {
        // 实现显示通知面板的逻辑
        GD.Print($"Notification: {message}");
    }
}
```

### 4. 最佳实践
1. **事件命名规范**：使用"On+动词+名词"的格式，如OnEnemyKilled、OnPlayerLevelUp
2. **参数封装**：对于复杂事件，使用专门的EventArgs类封装参数，提高类型安全性
3. **异常处理**：在事件总线中捕获异常，防止一个模块的错误影响其他模块
4. **集中管理事件**：使用EventNames类集中管理所有事件名称，避免拼写错误
5. **订阅时机**：在模块初始化时订阅必要的事件，在模块销毁时取消订阅
6. **事件文档**：为每个事件添加注释，说明事件的用途、参数含义和触发时机

### 5. 与游戏核心模块的集成
事件总线架构特别适合"吞噬修仙"游戏的以下核心系统：
- **吞噬系统**：吞噬完成后发布OnDevourCompleted事件，通知属性系统、UI系统等更新
- **战斗系统**：战斗开始/结束、角色受伤/击杀敌人等事件的发布与响应
- **角色系统**：角色属性变化、升级、装备变更等事件的通知
- **物品系统**：物品获取、使用、移除等事件的处理

通过事件总线，这些系统可以实现松耦合通信，每个系统只关注自己职责范围内的事件处理，提高代码的可维护性和扩展性。    // 取消订阅
    public static void Unsubscribe(string eventName, Action<object[]> callback)
    {
        if (_eventListeners.TryGetValue(eventName, out var listeners))
        {
            listeners.Remove(callback);
            if (listeners.Count == 0)
                _eventListeners.Remove(eventName);
        }
    }
}
```

### 方案二：采用中介者模式
**核心思想**：创建一个中介者对象，负责协调模块间的交互，模块只与中介者通信，而不直接相互引用。

**优点**：
- 减少模块间依赖，所有通信都通过中介者进行
- 集中控制交互逻辑，便于维护
- 适合模块间交互规则复杂的场景

**实现建议**：
```csharp
// 中介者接口
public interface IModuleMediator
{
    void RegisterModule(IModule module);
    void SendMessage(IModule sender, string message, params object[] args);
}

// 模块接口
public interface IModule
{
    string ModuleName { get; }
    void HandleMessage(string message, params object[] args);
}
```

### 方案三：依赖注入容器
**核心思想**：使用依赖注入容器管理模块间的依赖关系，模块通过接口而非具体实现进行通信。

**优点**：
- 解耦模块间的具体实现依赖
- 方便单元测试和模块替换
- 支持运行时动态替换依赖

**实现建议**：
```csharp
// 简单依赖注入容器示例
public class DIContainer
{
    private static readonly Dictionary<Type, object> _instances = new();

    public static void Register<T>(T instance)
    {
        _instances[typeof(T)] = instance;
    }

    public static T Resolve<T>()
    {
        if (_instances.TryGetValue(typeof(T), out var instance))
            return (T)instance;
        throw new Exception($"Type {typeof(T).Name} not registered